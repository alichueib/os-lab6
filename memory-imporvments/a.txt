fddjğŸ§© 3. What would happen in a real runtime

In a production runtime (like Intel TBB, OpenMP tasking, etc.), youâ€™d do one of two things:

âœ… Option 1: Reference counting

Each task would maintain:

unsigned int ref_count;


Initially 1.
Every child increments the parentâ€™s count when it is created.
When a task terminates, it decrements the parentâ€™s ref count.
When the count hits 0 â†’ you free that task_t.

This ensures memory is freed as soon as no one depends on it anymore.

âœ… Option 2: Central garbage collection

After runtime_finalize() or periodically, the runtime walks through all task records and frees those with status == TERMINATED and no parent references.

ğŸ§© 4. So yes â€” you are right

In the current version:

Each task_t stays in memory after completion.

Thatâ€™s a memory leak if you spawn many tasks.

But itâ€™s intentional for simplicity, since this runtime runs once and exits immediately after all tasks finish.

So the â€œbad memory managementâ€ is by design â€” they deliberately ignored freeing to make the logic easier to follow.

ğŸ§  Summary
Question	Answer
Are parent/child pointers kept alive in memory?	Yes, until the process ends
Is memory freed at runtime?	No
Is it a problem?	Only if you spawn millions of tasks or run indefinitely
Why not fix it now?	Because the lab focuses on task scheduling & dependencies, not memory management

Would you like me to show how a safe memory-freeing mechanism could be added without breaking the dependency logic (for learning purposes)?
